name: Full Stack - Infrastructure + Deployment

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'What to do?'
        required: true
        type: choice
        options:
          - create-and-deploy
          - deploy-only
          - destroy-all

env:
  AWS_REGION: us-east-1
  ECR_FRONTEND_REPOSITORY: dark-trifid-frontend
  ECR_BACKEND_REPOSITORY: dark-trifid-backend

jobs:
  # Job 1: Crear Infraestructura con Terraform
  create-infrastructure:
    name: Create Infrastructure
    if: github.event.inputs.action == 'create-and-deploy'
    runs-on: ubuntu-latest
    outputs:
      ec2_ip: ${{ steps.terraform-output.outputs.public_ip }}
      instance_id: ${{ steps.terraform-output.outputs.instance_id }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          cd terraform
          terraform init

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -out=tfplan

      - name: Terraform Apply
        run: |
          cd terraform
          terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        id: terraform-output
        run: |
          cd terraform
          PUBLIC_IP=$(terraform output -raw public_ip)
          INSTANCE_ID=$(terraform output -raw instance_id)
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "âœ… Infrastructure created with IP: $PUBLIC_IP"

      - name: Wait for Instance to be Ready
        run: |
          echo "â³ Waiting 90 seconds for instance to fully initialize..."
          sleep 90

      - name: Infrastructure Summary
        run: |
          echo "### ðŸ—ï¸ Infrastructure Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Instance ID:** \`${{ steps.terraform-output.outputs.instance_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Public IP:** \`${{ steps.terraform-output.outputs.public_ip }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "â­ï¸ **Next:** Deploying application..." >> $GITHUB_STEP_SUMMARY

  # Job 2: Build y Push a ECR
  build-and-push:
    name: Build and Push to ECR
    needs: [create-infrastructure]
    if: |
      always() &&
      (github.event.inputs.action == 'create-and-deploy' || github.event.inputs.action == 'deploy-only') &&
      (needs.create-infrastructure.result == 'success' || needs.create-infrastructure.result == 'skipped')
    runs-on: ubuntu-latest
    outputs:
      frontend_image: ${{ steps.build-frontend.outputs.image }}
      backend_image: ${{ steps.build-backend.outputs.image }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure ECR Repositories Exist
        run: |
          echo "ðŸ” Checking ECR repositories..."
          
          # Check and create frontend repository
          if ! aws ecr describe-repositories --repository-names $ECR_FRONTEND_REPOSITORY --region $AWS_REGION 2>/dev/null; then
            echo "Creating frontend repository..."
            aws ecr create-repository \
              --repository-name $ECR_FRONTEND_REPOSITORY \
              --region $AWS_REGION \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256
            echo "âœ… Frontend repository created"
          else
            echo "âœ… Frontend repository already exists"
          fi
          
          # Check and create backend repository
          if ! aws ecr describe-repositories --repository-names $ECR_BACKEND_REPOSITORY --region $AWS_REGION 2>/dev/null; then
            echo "Creating backend repository..."
            aws ecr create-repository \
              --repository-name $ECR_BACKEND_REPOSITORY \
              --region $AWS_REGION \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256
            echo "âœ… Backend repository created"
          else
            echo "âœ… Backend repository already exists"
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push Frontend image
        id: build-frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG -f frontend/Dockerfile .
          docker tag $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest
          echo "image=$ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build, tag, and push Backend image
        id: build-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG -f backend/Dockerfile backend/
          docker tag $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest
          echo "image=$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build Summary
        run: |
          echo "### ðŸ³ Docker Images Built and Pushed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend:** \`${{ steps.build-frontend.outputs.image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Backend:** \`${{ steps.build-backend.outputs.image }}\`" >> $GITHUB_STEP_SUMMARY

  # Job 3: Deploy a EC2
  deploy-to-ec2:
    name: Deploy Application to EC2
    needs: [create-infrastructure, build-and-push]
    if: |
      always() &&
      (github.event.inputs.action == 'create-and-deploy' || github.event.inputs.action == 'deploy-only') &&
      needs.build-and-push.result == 'success'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Determine EC2 Host
        id: ec2-host
        run: |
          if [ "${{ github.event.inputs.action }}" == "create-and-deploy" ]; then
            echo "host=${{ needs.create-infrastructure.outputs.ec2_ip }}" >> $GITHUB_OUTPUT
            echo "instance_id=${{ needs.create-infrastructure.outputs.instance_id }}" >> $GITHUB_OUTPUT
          else
            echo "host=${{ secrets.EC2_HOST }}" >> $GITHUB_OUTPUT
            # Get instance ID from IP
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=ip-address,Values=${{ secrets.EC2_HOST }}" "Name=instance-state-name,Values=running" \
              --query "Reservations[0].Instances[0].InstanceId" \
              --output text)
            echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to EC2 via SSM
        env:
          INSTANCE_ID: ${{ steps.ec2-host.outputs.instance_id }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          FRONTEND_IMAGE: ${{ needs.build-and-push.outputs.frontend_image }}
          BACKEND_IMAGE: ${{ needs.build-and-push.outputs.backend_image }}
        run: |
          echo "ðŸš€ Deploying to EC2 instance: $INSTANCE_ID"
          
          # Wait for SSM agent to be ready
          echo "â³ Waiting for SSM agent..."
          aws ssm wait command-executed --instance-ids "$INSTANCE_ID" --command-id "test" 2>/dev/null || echo "SSM ready"
          
          # Send deployment commands via SSM
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "#!/bin/bash",
              "set -e",
              "export HOME=/home/ec2-user",
              "export USER=ec2-user",
              "cd /home/ec2-user",
              "echo \"=== Starting deployment ===\"",
              "cd dark-trifid",
              "sudo -u ec2-user git config --global --add safe.directory /home/ec2-user/dark-trifid",
              "sudo -u ec2-user git pull origin main",
              "aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin '"$ECR_REGISTRY"'",
              "export ECR_REGISTRY='"$ECR_REGISTRY"'",
              "docker compose down",
              "docker pull '"$FRONTEND_IMAGE"'",
              "docker pull '"$BACKEND_IMAGE"'",
              "docker tag '"$FRONTEND_IMAGE"' '"$ECR_REGISTRY"'/dark-trifid-frontend:latest",
              "docker tag '"$BACKEND_IMAGE"' '"$ECR_REGISTRY"'/dark-trifid-backend:latest",
              "docker compose -f docker-compose.prod.yml up -d --force-recreate",
              "docker image prune -f",
              "echo \"=== Deployment completed ===\"",
              "docker compose ps",
              "echo \"Frontend image: $(docker inspect dark-trifid-frontend --format='{{.Image}}')\"",
              "echo \"Backend image: $(docker inspect dark-trifid-backend --format='{{.Image}}')\""
            ]' \
            --output text \
            --query "Command.CommandId")
          
          echo "ðŸ“ Command ID: $COMMAND_ID"
          echo "â³ Waiting for deployment to complete..."
          
          # Wait for command to complete
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" || true
          
          # Get command output
          echo "ðŸ“Š Deployment output:"
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" \
            --output text
          
          # Check if command succeeded
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "Status" \
            --output text)
          
          if [ "$STATUS" != "Success" ]; then
            echo "âŒ Deployment failed with status: $STATUS"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "StandardErrorContent" \
              --output text
            exit 1
          fi
          
          echo "âœ… Deployment successful!"

      - name: Verify Deployment
        env:
          EC2_HOST: ${{ steps.ec2-host.outputs.host }}
        run: |
          echo "### âœ… Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Application URL:** http://$EC2_HOST" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend Image:** \`${{ needs.build-and-push.outputs.frontend_image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Backend Image:** \`${{ needs.build-and-push.outputs.backend_image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ‰ Your application is now live!" >> $GITHUB_STEP_SUMMARY

  # Job 4: Destroy Infrastructure
  destroy-infrastructure:
    name: Destroy Infrastructure
    if: github.event.inputs.action == 'destroy-all'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform Init
        run: |
          cd terraform
          terraform init

      - name: Terraform Destroy
        run: |
          cd terraform
          terraform destroy -auto-approve

      - name: Destruction Summary
        run: |
          echo "### ðŸ—‘ï¸ Infrastructure Destroyed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All AWS resources have been destroyed." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Note:** ECR images are NOT deleted. Clean them manually if needed." >> $GITHUB_STEP_SUMMARY
